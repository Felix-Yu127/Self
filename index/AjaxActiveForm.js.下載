/**
 * @author jack.zhu
 * AjaxActiveForm widget js file
 */

	/**
	 * AjaxActiveForm set function.
	 * @param options map settings for the active form plugin. Please see {@link CActiveForm::options} for availablel options.
	 */
	$.fn.AjaxActiveForm = function (options) {
		return this.each(function () {			
			var settings = $.extend({}, $.fn.AjaxActiveForm.defaults, options || {}),
				$form = $(this);

			if (settings.validationUrl === undefined) {
				settings.validationUrl = $form.attr('action');
			}
			if(typeof options.revert != "undefined" && (typeof options.revert == "object" || typeof options.revert == "function")){
				$form.data('revert', options.revert);
			}else{
				$form.data('revert', function(){});
			}
			$.each(settings.attributes, function (i) {
				this.value = $.fn.AjaxActiveForm.getAFValue($form.find('#' + this.inputID), this);
				settings.attributes[i] = $.extend({}, {
					validationDelay: settings.validationDelay,
					validateOnChange: settings.validateOnChange,
					validateOnType: settings.validateOnType,
					hideErrorMessage: settings.hideErrorMessage,
					inputContainer: settings.inputContainer,
					errorCssClass: settings.errorCssClass,
					successCssClass: settings.successCssClass,
					beforeValidateAttribute: settings.beforeValidateAttribute,
					afterValidateAttribute: settings.afterValidateAttribute,
					validatingCssClass: settings.validatingCssClass
				}, this);
			});
			$form.data('settings', settings);
		
			settings.submitting = false;  // whether it is waiting for ajax submission result
			settings.ajaxsubmitting = false;  //ajaxsubmitting is running 
			settings.validateOnSubmit = true; //validateOnSubmit this is not an option for AjaxActiveForm
			var validate = function (attribute, forceValidate) {
				
				if (forceValidate) {
					attribute.status = 2;
				}
				$.each(settings.attributes, function () {
					if (this.value !== $.fn.AjaxActiveForm.getAFValue($form.find('#' + this.inputID), this)) {
						this.status = 2;
						forceValidate = true;
					}
				});
				if (!forceValidate) {
					return;
				}

				if (settings.timer !== undefined) {
					clearTimeout(settings.timer);
				}
				settings.timer = setTimeout(function () {
					if (settings.submitting || $form.is(':hidden')) {
						return;
					}
					if (attribute.beforeValidateAttribute === undefined || attribute.beforeValidateAttribute($form, attribute)) {
						$.each(settings.attributes, function () {
							if (this.status === 2) {
								this.status = 3;
							}
						});
						$.fn.AjaxActiveForm.validate($form, function (data) {
							var hasError = false;
							$form.data('settings').errorShowingId = [];
							$.each(settings.attributes, function () {
								if (this.status === 2 || this.status === 3) {
									hasError = $.fn.AjaxActiveForm.updateInput(this, data, $form) || hasError;
								}
							});
							if (attribute.afterValidateAttribute !== undefined) {
								attribute.afterValidateAttribute($form, attribute, data, hasError);
							}
						});
					}
				}, attribute.validationDelay);
			};

			$.each(settings.attributes, function (i, attribute) {
				if (this.validateOnChange) {
					$form.find('#' + this.inputID).change(function () {
						validate(attribute, false);
					}).blur(function () {
						if (attribute.status !== 2 && attribute.status !== 3) {
							validate(attribute, !attribute.status);
						}
					});
				}
				if (this.validateOnType) {
					var that = this;
					$form.find('#' + this.inputID).keyup(function () {
						if (attribute.value !== $.fn.AjaxActiveForm.getAFValue($(this),that)) {
							validate(attribute, false);
						}
					});
				}
			});

			if (settings.validateOnSubmit) {
				$form.on('mouseup keyup', ':submit', function () {
					$form.data('submitObject', $(this));
				});
				var validated = false;
				$form.submit(function (event) {
					if (settings.timer !== undefined) {
						clearTimeout(settings.timer);
					}
					settings.submitting = true;
					if (settings.beforeValidate === undefined || settings.beforeValidate($form)) {
						$.fn.AjaxActiveForm.validate($form, function (data) {
							var hasError = false;
							$form.data('settings').errorShowingId = [];
							$.each(settings.attributes, function () {
								hasError = $.fn.AjaxActiveForm.updateInput(this, data, $form) || hasError;
							});
							$.fn.AjaxActiveForm.updateSummary($form, data);
							if (settings.afterValidate === undefined || settings.afterValidate($form, data, hasError)) {

								if (!hasError) {
									validated = true;

									if(!settings.ajaxsubmitting && (settings.beforeSubmit === undefined || settings.beforeSubmit($form)))
									{
										var $button = $form.data('submitObject'),
											extData = '&' + settings.ajaxVar + '=' + $form.attr('id');
										if ($button && $button.length) {
											extData += '&' + $button.attr('name') + '=' + $button.attr('value');
										}

										settings.ajaxsubmitting = true;
										my104Ajax({
											url : $form.attr('action'),
											type : $form.attr('method'),
											data : $form.serialize() + extData,
											dataType : 'json',
											success : function (data) {
												validated = false;
												settings.ajaxsubmitting = false;
												settings.submitting = false;
												if (
													data !== null 
													&& typeof data === 'object'
													&& typeof data.Err === 'object' 
													&& typeof data.UserData !== 'undefined'
												) {
													if(typeof data.revert != "undefined" && typeof data.revert == "string"){
														eval("var revert="+data.revert);
														$form.data('revert', revert);
													}
													if(typeof data.UserData.surveyUrl != "undefined" && data.UserData.surveyUrl != ""){
														window.open(data.UserData.surveyUrl,'newwindow','');
													}
													if(typeof data.UserData.unlockButian !== 'undefined' && data.UserData.unlockButian == 1)
													{
														window.location.reload();
													}	
													$.each(settings.attributes, function () {
														hasError = $.fn.AjaxActiveForm.updateInput(this, data.Err, $form) || hasError;
													});
													if(settings.afterServerValidate === undefined || settings.afterServerValidate($form, data, hasError)){
														if(!hasError && settings.onSubmitSuccess !== undefined){
															settings.onSubmitSuccess($form, data);
														}
													}
												} else if(settings.onSubmitError  !== undefined){
													settings.onSubmitError($form, data, 'return data struct error');
												}
											},
											error : function (jqXHR, textStatus, errorThrown) {
												validated = false;
												settings.ajaxsubmitting = false;
												settings.submitting = false;
												if(settings.onSubmitError  !== undefined){
													settings.onSubmitError($form, data, textStatus);
												}
											}
										});									
									}
								}
								
							}
							settings.submitting = false;
						});
					} else {
						settings.submitting = false;
					}
					event.preventDefault();
					return false;
				});
			}

			/*
			 * In case of reseting the form we need to reset error messages
			 * NOTE1: $form.reset - does not exist
			 * NOTE2: $form.on('reset', ...) does not work
			 */
			$form.bind('reset', function () {
				/*
				 * because we bind directly to a form reset event, not to a reset button (that could or could not exist),
				 * when this function is executed form elements values have not been reset yet,
				 * because of that we use the setTimeout
				 */
				setTimeout(function () {
					$.each(settings.attributes, function () {
						this.status = 0;
						var $error = $form.find('#' + this.errorID),
							$input = $form.find('#' + this.inputID)
							$container = $.fn.AjaxActiveForm.getInputContainer(this, $form);

						$container.removeClass(
							this.validatingCssClass + ' ' +
							this.errorCssClass + ' ' +
							this.successCssClass							 
						);
						
						$input.removeClass(
							this.validatingCssClass + ' ' +
							this.errorCssClass + ' ' +
							this.successCssClass
						);

						$error.html('').hide();

						/*
						 * without the setTimeout() we would get here the current entered value before the reset instead of the reseted value
						 */
						this.value = $.fn.AjaxActiveForm.getAFValue($input,this);
					});
					/*
					 * If the form is submited (non ajax) with errors, labels and input gets the class 'error'
					 */
					$form.find('label, input').each(function () {
						$(this).removeClass('error');
					});
					$('#' + settings.summaryID).hide().find('ul').html('');
					//.. set to initial focus on reset
					if (settings.focus !== undefined && !window.location.hash) {
						$form.find(settings.focus).focus();
					}
				}, 1);
			});

			/*
			 * set to initial focus
			 */
			if (settings.focus !== undefined && !window.location.hash) {
				$form.find(settings.focus).focus();
			}
		});
	};

	/**
	 * Returns the container element of the specified attribute.
	 * @param attribute object the configuration for a particular attribute.
	 * @param form the form jQuery object
	 * @return jQuery the jQuery representation of the container
	 */
	$.fn.AjaxActiveForm.getInputContainer = function (attribute, form) {
		if (attribute.inputContainer === undefined) {
			return form.find('#' + attribute.inputID).closest('div');
		} else {
			return form.find(attribute.inputContainer).filter(':has("#' + attribute.inputID + '")');
		}
	};
	
	
	$.fn.AjaxActiveForm.getAFValue = function (o,a) {
		var type,
			c = [];
		if (!o.length) {
			return undefined;
		}
		//radio button list
		if ($.inArray(o[0].tagName.toLowerCase(),['input','select','textarea','keygen']) < 0) {
			var sel = '';
			if(typeof a === 'object' && typeof a.inputName =='string'){
				sel = '[name="'+a.inputName.replace(/([\!\"\#\$\%\&\'\(\)\*\+\,\.\/\:\;\<\=\>\?\@\[\\\]\^\`\{\|\}\~])/g,'\\$1')+'"]';
			}			
			o.find(sel+':checked').each(function () {
				c.push(this.value);
			});
			return c.join(',');
		}
		type = o.attr('type');
		if (type === 'checkbox' || type === 'radio') {
			return o.filter(':checked').val();
		} else {
			return o.val();
		}
	};
	
	
	/**
	 * updates the error message and the input container for a particular attribute.
	 * @param attribute object the configuration for a particular attribute.
	 * @param messages array the json data obtained from the ajax validation request
	 * @param form the form jQuery object
	 * @return boolean whether there is a validation error for the specified attribute
	 */
	$.fn.AjaxActiveForm.updateInput = function (attribute, messages, $form) {
		attribute.status = 1;
		var $error,
			hasError = false,
			$input = $form.find('#' + attribute.inputID),
			showingId = $form.data('settings').errorShowingId;

		if ($input.length) {
			hasError = messages !== null && (($.isArray(messages[attribute.id]) && messages[attribute.id].length > 0) || ($.isArray(messages[attribute.inputID]) && messages[attribute.inputID].length > 0) ) ;
			$error = $form.find('#' + attribute.errorID);
			
			var $container = $.fn.AjaxActiveForm.getInputContainer(attribute, $form);
			
			$container.removeClass(
				attribute.validatingCssClass + ' ' +
				attribute.errorCssClass + ' ' +
				attribute.successCssClass							 
			);

			$input.removeClass(
				attribute.validatingCssClass + ' ' +
				attribute.errorCssClass + ' ' + 
				attribute.successCssClass
			);
			if (hasError) {
				$error.html((messages[attribute.id]||messages[attribute.inputID])[0]);
			} else if (attribute.enableAjaxValidation || attribute.clientValidation) {
			}
			if (!attribute.hideErrorMessage) {
				if((!hasError && $.inArray(attribute.errorID, showingId) < 0) || hasError){
					$error.toggle(hasError);
				}
				if(hasError){
					showingId.push(attribute.errorID);
				}

			}

			attribute.value = $.fn.AjaxActiveForm.getAFValue($input, attribute);
		}
		return hasError;
	};

	/**
	 * updates the error summary, if any.
	 * @param form jquery the jquery representation of the form
	 * @param messages array the json data obtained from the ajax validation request
	 */
	$.fn.AjaxActiveForm.updateSummary = function (form, messages) {
		var settings = $(form).data('settings'),
			content = '';
		if (settings.summaryID === undefined) {
			return;
		}
		if (messages) {
			$.each(settings.attributes, function () {
				if ($.isArray(messages[this.id])) {
					$.each(messages[this.id], function (j, message) {
						content = content + '<li>' + message + '</li>';
					});
				}
			});
		}
		$('#' + settings.summaryID).toggle(content !== '').find('ul').html(content);
	};

	/**
	 * Performs the ajax validation request.
	 * This method is invoked internally to trigger the ajax validation.
	 * @param form jquery the jquery representation of the form
	 * @param successCallback function the function to be invoked if the ajax request succeeds
	 * @param errorCallback function the function to be invoked if the ajax request fails
	 */
	$.fn.AjaxActiveForm.validate = function (form, successCallback, errorCallback) {
		var $form = $(form),
			settings = $form.data('settings'),
			needAjaxValidation = false,
			messages = {};
		$.each(settings.attributes, function () {
			var value,
				msg = [];
			if (this.clientValidation !== undefined && (settings.submitting || this.status === 2 || this.status === 3)) {
				value = $.fn.AjaxActiveForm.getAFValue($form.find('#' + this.inputID), this);
				this.clientValidation(value, msg, this);
				if (msg.length) {
					messages[this.id] = msg;
				}
			}
			if (this.enableAjaxValidation && !msg.length && (settings.submitting || this.status === 2 || this.status === 3)) {
				
				needAjaxValidation = false;
			}
		});

		if (!needAjaxValidation || settings.submitting && !$.isEmptyObject(messages)) {
			if (settings.submitting) {
				// delay callback so that the form can be submitted without problem
				setTimeout(function () {
					successCallback(messages);
				}, 200);
			} else {
				successCallback(messages);
			}
			return;
		}

		// move ajax validate
	};

	/**
	 * Returns the configuration for the specified form.
	 * The configuration contains all needed information to perform ajax-based validation.
	 * @param form jquery the jquery representation of the form
	 * @return object the configuration for the specified form.
	 */
	$.fn.AjaxActiveForm.getSettings = function (form) {
		return $(form).data('settings');
	};
	$.fn.AjaxActiveForm.defaults = {
		ajaxVar: 'ajax',
		validationUrl: undefined,
		validationDelay: 200,
		validateOnSubmit : true,
		validateOnChange : false,
		validateOnType : false,
		hideErrorMessage : false,
		inputContainer : undefined,
		errorCssClass : 'error',
		successCssClass : 'success',
		validatingCssClass : 'validating',
		summaryID : undefined,
		timer: undefined,
		beforeValidateAttribute: undefined, // function (form, attribute) : boolean
		afterValidateAttribute: undefined,  // function (form, attribute, data, hasError)
		beforeValidate: undefined, // function (form) : boolean
		afterValidate: undefined,  // function (form, data, hasError) : boolean
		afterServerValidate: undefined,  // function (form, data, hasError) : boolean
		errorShowingId : [],
		beforeSubmit : undefined, //function (form) : boolean
		onSubmitSuccess : undefined,  //function (form, data)
		onSubmitError : undefined, //function (form, data, textStatus)
		/**
		 * list of attributes to be validated. Each array element is of the following structure:
		 * {
		 *     id : 'ModelClass_attribute', // the unique attribute ID
		 *     model : 'ModelClass', // the model class name
		 *     name : 'name', // attribute name
		 *     inputID : 'input-tag-id',
		 *     inputName : 'input-name',
		 *     errorID : 'error-tag-id',
		 *     value : undefined,
		 *     status : 0,  // 0: empty, not entered before,  1: validated, 2: pending validation, 3: validating
		 *     focus : undefined,  // jquery selector that indicates which element to receive input focus initially
		 *     validationDelay: 200,
		 *     validateOnChange : true,
		 *     validateOnType : false,
		 *     hideErrorMessage : false,
		 *     inputContainer : undefined,
		 *     errorCssClass : 'error',
		 *     successCssClass : 'success',
		 *     validatingCssClass : 'validating',
		 *     enableAjaxValidation : true,
		 *     enableClientValidation : true,
		 *     clientValidation : undefined, // function (value, messages, attribute) : client-side validation
		 *     beforeValidateAttribute: undefined, // function (form, attribute) : boolean
		 *     afterValidateAttribute: undefined,  // function (form, attribute, data, hasError)
		 * }
		 */
		attributes : []
	};
